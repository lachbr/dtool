# Rules to construct .so's from component files.

ifneq (,$(SOLOCATIONS))
.PRECIOUS: $(SOLOCATIONS)
  ifeq (SGI,$(PENV))
    ifeq (ld,$(LD))
      SLOC := -update_registry $(SOLOCATIONS)
    else
      SLOC := -Wl,-update_registry,$(SOLOCATIONS)
    endif
  endif  # (SGI,$(PENV))
endif  # $(SOLOCATIONS)


ifeq (SGI,$(PENV))
  ifeq (ld,$(LD))
    NONE = -none
  else
    NONE = -Wl,-none
  endif

  DEFINE_SONAME = -soname $@
endif  # (SGI,$(PENV))

ifeq (SunOS,$(PENV))
  SHARED_COMMAND = -G
else
  ifeq (OSX,$(PENV))
    SHARED_COMMAND = -dynamiclib
  else
    SHARED_COMMAND = -shared
  endif
endif  # (SunOS,$(PENV))

ifeq (OSX,$(PENV))
ALL = 
else
ALL = -all
endif  # (OSX,$(PENV))
BASEFILE =

ALLOFILES := $(ALLOFILES) $(OFILES)

ifeq (,$(USE_DEFERRED))
  LIBS := $(WHEN_NO_DEFER_LIBS) $(LIBS)
else
  LIBS := $(WHEN_DEFER_LIBS) $(LIBS)
endif

ifeq (,$(USE_DEFERRED))
  SHOULD_DEFER_TARGET :=
else
  SHOULD_DEFER_TARGET := $(DEFERRED_TARGET)
endif

ifneq (,$(SHOULD_DEFER_TARGET))

  # If the makefile requests a "deferred target", it means that we'll
  # just write out a mini-makefile that defines the .o files that go
  # into the target, rather than actually building the target now.
  # Another Makefile later will presumably do the actual building.

  DEFERRED_MAKEFILE := Deferred.$(DEFERRED_TARGET).$(BASETARGET)
  THISDIR := $(notdir $(shell pwd))

$(TARGET) : $(DEFERRED_MAKEFILE)
$(DEFERRED_MAKEFILE): $(wildcard Makefile.*)
	rm -f $@
	echo ALLOFILES += $(patsubst ./%,../../src/$(THISDIR)/%,$(ALLOFILES)) > $@

else # DEFERRED_TARGET

  ifneq (,$(strip $(ALLOFILES)))

  # This is less than ideal.  This means that the .so file doesn't get
  # added to the configuration record, and hence gets none of the
  # clearmake magic like derived-object status and winking in.
  # However, it also means that clearmake doesn't get tricked by the
  # so_locations file, so it seems to be a better choice than the
  # alternative for the moment.
  .NO_CONFIG_REC: $(TARGET)

  TARGETLIB =
  BASELIB =
  DEFLIB =
  EXPLIB =
  PDBLIB =
  LIBLIB =
  VCFILES =

  # Eliminate -lm and -ldl on NT because they don't exist
  WINLIBS := $(filter-out -lm -ldl,$(SYSLIBS))
  # On NT -l<library> needs to map to lib<library>.lib
  WINLIBS := $(LIBS:-l%=lib%$(DEBUGNAME).lib) $(WINLIBS:-l%=lib%.lib)
  # We also need to handle any explicitly listed .a libraries 
  WINLIBS := $(WINLIBS:%.a=%.lib)
  ifeq (WIN32_VC,$(PENV_COMPILER))
    PDBLIB := $(TARGET:%.dll=%.pdb)
    EXPLIB := $(TARGET:%.dll=%.exp)
    LIBLIB := $(TARGET:%.dll=%.lib)
    VCFILES := vc60.idb vc60.pdb
  endif # WIN32_VC
  
  $(TARGET): $(OFILES)  # *not* ALLOFILES

  #### The PlayStation2 doesn't do .so files AT ALL.
  #### Solution: Every time panda/tool wants a .so, we make a .a

  ifeq (PS2, $(PENV))
	ee-ar -r a.out.$@ $(ALLOFILES)
  else
  ifeq (WIN32,$(PENV))
    ifeq (WIN32_VC,$(PENV_COMPILER))
	$(LD) $(LDFLAGS) $(LDTYPE) \
		$(LPATH) $(LINKFLAGS) $(ALLOFILES) $(WINLIBS) -OUT:$@
    endif # PENV_COMPILER 
  else # NON-WIN32 
    ifeq (OSX,$(PENV))
	$(LD) $(SHARED_COMMAND) $(PTR) $(PTFLAGS) $(SLOC) $(LDFLAGS) \
              $(LPATH) $(ALL) $(ALLOFILES) \
              $(NONE) $(LIBS) $(SYSLIBS) -o $@ $(DEFINE_SONAME) \
              $(BASEFILE) $(BASELIB) -lstdc++
    else # non-win32 and non-OSX
	$(LD) $(SHARED_COMMAND) $(PTR) $(PTFLAGS) $(SLOC) $(LDFLAGS) \
		$(LPATH) $(ALL) $(ALLOFILES) \
		$(NONE) $(LIBS) $(SYSLIBS) -o a.out.$@ $(DEFINE_SONAME) \
		$(BASEFILE) $(BASELIB)
    endif # non-win32 and non-OSX
  endif # WIN32 
  endif # PS2
  
  ifneq (WIN32,$(PENV))
    ifneq (OSX,$(PENV))
	mv a.out.$@ $@
    endif # non-win32 and non-OSX
    ifneq (SGI,$(PENV))
      ifeq (4,$(OPTIMIZE))
	strip $@
      endif # (4,$(OPTIMIZE))
    endif # (SGI,$(PENV))
  endif
  
  endif # (,$(ALLOFILES))

endif   # DEFERRED_TARGET
  
clean::
	@rm -f $(TARGET) $(TARGETLIB) $(BASELIB) $(DEFLIB) $(EXPLIB) \
		$(WINLIBS) $(PDBLIB) $(LIBLIB) $(VCFILES)

cleanall: clean
	rm -fr ii_files
	rm -f $(TARGET) $(TARGETLIB) $(BASELIB) $(DEFLIB) $(EXPLIB) \
		$(WINLIBS) $(PDBLIB) $(LIBLIB) $(VCFILES)

list:
	@echo $(TARGET) $(TARGETLIB) $(BASELIB) $(DEFLIB) $(EXPLIB) \
		$(WINLIBS) $(PDBLIB) $(LIBLIB)
