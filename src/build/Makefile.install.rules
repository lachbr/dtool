#### Makefile install rules.  Setup. 
strip-target = `echo $@ | sed 's/^[^-]*-//'`

# Yank out any whitespace in the package name.
PACKAGE := $(strip $(PACKAGE))

# Pull in standard install make variables.
ifeq (,$(MAKEFILE_INSTALL_VARS))
include $(DTOOL)/inc/Makefile.install.vars
endif

# We need this one to define DEBUGNAME for us.
ifeq (,$(MAKEFILE_O_VARS))
include $(DTOOL)/inc/Makefile.o.vars
endif

# Infer the package root from the package name, if not already set.
ifeq (,$(PKGROOT))
PKGROOT = src/all/$(PACKAGE)
else
PKGROOT := $(strip $(PKGROOT))
endif


# First target.  Convenient synonym for install.
$(PACKAGE): install-$(PACKAGE)
$(PKGROOT): install-$(PKGROOT)



#### File install actions
#
# This section constructs lists of installed files, and the source files
# from which they are copied.  Then the user supplied list is cleared.
# This is because this rules file is included in the project Makefile
# more than once, and we'd rather not have one package's file list
# affecting the installation of another package that follows it.
#
# Each installed file depends on the existence of a source file from
# which to copy it.  Each block below is for a different installation
# directory.  The ALLSRC and ALLINST lists will be used in the next sections 
# of the rules.  More such blocks may be added by following the pattern.
#

ALLSRC = 
ALLINST = 


# DEFERRED supplied by package's Makefile.install.  If defined (and
# not overridden in Makefile.penv.vars), this indicates that a
# deferred build is requested by the makefiles in this package, and we
# should install only the output of these deferred builds.  This,
# therefore, overrides any request to install LIBS.

ifeq (,$(USE_DEFERRED))
  DEFERRED :=
endif

ifeq (PS2, $(PENV))
  SOLIBS := $(filter %.so,$(LIBS))
  SOLIBS := $(SOLIBS:%.so=%.a)
  ALIBS := $(filter %.a,$(LIBS))
  LIBS := $(SOLIBS)
  LIBS += $(ALIBS)
endif

SRCDEFERRED := $(addprefix $(PKGROOT)/,$(DEFERRED))
ALLSRC := $(ALLSRC) $(SRCDEFERRED)
INSTDEFERRED := $(addprefix deferred/,$(DEFERRED))
ALLINST := $(ALLINST) $(INSTDEFERRED)
DEFERRED = 

ifneq (,$(INSTDEFERRED))
$(INSTDEFERRED): deferred/% : $(PKGROOT)/%
	$(MKINSTALL)
endif

# LIBS supplied by package's Makefile.install.
ifeq (WIN32,$(PENV))
  SOLIBS := $(filter %.so,$(LIBS))
  SOLIBS := $(SOLIBS:%.so=%$(DEBUGNAME).dll)
  ALIBS := $(filter %.a,$(LIBS))
  ALIBS := $(ALIBS:%.a=%$(DEBUGNAME).lib)
  LIBS := $(SOLIBS:%.dll=%.lib)
  LIBS += $(ALIBS)
  LIBS += $(SOLIBS)
endif # WIN32
ifeq (OSX,$(PENV))
  SOLIBS := $(filter %.so,$(LIBS))
  SOLIBS := $(SOLIBS:%.so=%.dylib)
  ALIBS := $(filter %.a,$(LIBS))
  LIBS := $(ALIBS)
  LIBS += $(SOLIBS)
endif # OSX

SRCLIBS := $(addprefix $(PKGROOT)/,$(LIBS))
ALLSRC := $(ALLSRC) $(SRCLIBS)
INSTLIBS := $(addprefix lib/,$(LIBS))
ALLINST := $(ALLINST) $(INSTLIBS)
LIBS = 

ifeq (,$(INSTDEFERRED))
  ifneq (,$(INSTLIBS))
    $(INSTLIBS): lib/% : $(PKGROOT)/%
	$(MKINSTALL)
  endif
else
  ifneq (,$(INSTLIBS))
    $(INSTLIBS):
  endif
endif
  

# INCLUDE supplied by package's Makefile.install.
INCLUDE := $(strip $(INCLUDE))
SRCINCLUDE := $(addprefix $(PKGROOT)/,$(INCLUDE))
ALLSRC := $(ALLSRC) $(SRCINCLUDE)
INSTINCLUDE := $(addprefix inc/,$(INCLUDE))
ALLINST := $(ALLINST) $(INSTINCLUDE)
INCLUDE = 

ifneq (,$(INSTINCLUDE))
$(INSTINCLUDE): inc/% : $(PKGROOT)/%
	$(MKINSTALL)
endif


# BINS supplied by package's Makefile.install.
BINS := $(strip $(BINS))
ifeq (WIN32,$(PENV))
  BINS := $(BINS:%=%.exe)
endif
SRCBINS := $(addprefix $(PKGROOT)/,$(BINS))
ALLSRC := $(ALLSRC) $(SRCBINS)
INSTBINS := $(addprefix bin/,$(BINS))
ALLINST := $(ALLINST) $(INSTBINS)
BINS = 

ifneq (,$(INSTBINS))
  $(INSTBINS): bin/% : $(PKGROOT)/%
	$(MKINSTALL)
	@chmod +x $@
endif


# SCRIPTS supplied by package's Makefile.install.
SCRIPTS := $(strip $(SCRIPTS))
SRCSCRIPTS := $(addprefix $(PKGROOT)/,$(SCRIPTS))
ALLSRC := $(ALLSRC) $(SRCSCRIPTS)
INSTSCRIPTS := $(addprefix bin/,$(SCRIPTS))
ALLINST := $(ALLINST) $(INSTSCRIPTS)
SCRIPTS = 

ifneq (,$(INSTSCRIPTS))
$(INSTSCRIPTS): bin/% : $(PKGROOT)/%
	$(MKINSTALL)
	@chmod +x $@
endif


# SS supplied by package's Makefile.install.
SS := $(strip $(SS))
SRCSS := $(addprefix $(PKGROOT)/,$(SS))
ALLSRC := $(ALLSRC) $(SRCSS)
INSTSS := $(addprefix lib/ss/,$(SS))
ALLINST := $(ALLINST) $(INSTSS)
SS =

ifneq (,$(INSTSS))
$(INSTSS): lib/ss/% : $(PKGROOT)/%
	$(MKINSTALL)
endif


# ST supplied by package's Makefile.install.
ST := $(strip $(ST))
SRCST := $(addprefix $(PKGROOT)/,$(ST))
ALLSRC := $(ALLSRC) $(SRCST)
INSTST := $(addprefix lib/st/,$(ST))
ALLINST := $(ALLINST) $(INSTST)
ST =

ifneq (,$(INSTST))
$(INSTST): lib/st/% : $(PKGROOT)/%
	$(MKINSTALL)
endif


# STK supplied by package's Makefile.install.
STK := $(strip $(STK))
SRCSTK := $(addprefix $(PKGROOT)/,$(STK))
ALLSRC := $(ALLSRC) $(SRCSTK)
INSTSTK := $(addprefix lib/stk/,$(STK))
ALLINST := $(ALLINST) $(INSTSTK)
STK =

ifneq (,$(INSTSTK))
$(INSTSTK): lib/stk/% : $(PKGROOT)/%
	$(MKINSTALL)
endif


# ETC supplied by package's Makefile.install.
ETC := $(strip $(ETC))
SRCETC := $(addprefix $(PKGROOT)/,$(ETC))
ALLSRC := $(ALLSRC) $(SRCETC)
INSTETC := $(addprefix etc/,$(ETC))
ALLINST := $(ALLINST) $(INSTETC)
ETC = 

ifneq (,$(INSTETC))
$(INSTETC): etc/% : $(PKGROOT)/%
	$(MKINSTALL)
endif


# IGATEDB supplied by package's Makefile.install.
ifeq (,$(NO_INTERROGATE))
IGATEDB := $(strip $(IGATEDB))
SRCIGATEDB := $(addprefix $(PKGROOT)/,$(IGATEDB))
ALLSRC := $(ALLSRC) $(SRCIGATEDB)
INSTIGATEDB := $(addprefix etc/,$(IGATEDB))
ALLINST := $(ALLINST) $(INSTIGATEDB)
IGATEDB = 

ifneq (,$(INSTIGATEDB))
$(INSTIGATEDB): etc/% : $(PKGROOT)/%
	$(MKINSTALL)
endif
endif


# MODELS supplied by package's Makefile.install.
MODELS := $(strip $(MODELS))
SRCMODELS := $(addprefix $(PKGROOT)/,$(MODELS))
ALLSRC := $(ALLSRC) $(SRCMODELS)
INSTMODELS := $(addprefix etc/models/, $(MODELS))
ALLINST := $(ALLINST) $(INSTMODELS)
MODELS = 

ifneq (, $(INSTMODELS))
$(INSTMODELS): etc/models/% : $(PKGROOT)/%
	$(MKINSTALL)
endif


# DOC supplied by package's Makefile.install.
DOC := $(strip $(DOC))
SRCDOC := $(addprefix $(PKGROOT)/,$(DOC))
ALLSRC := $(ALLSRC) $(SRCDOC)
INSTDOC := $(addprefix doc/,$(DOC))
ALLINST := $(ALLINST) $(INSTDOC)
DOC = 

ifneq (,$(INSTDOC))
$(INSTDOC): doc/% : $(PKGROOT)/%
	$(MKINSTALL)
endif


# MAN supplied by package's Makefile.install.
MAN := $(strip $(MAN))
SRCMAN := $(addprefix $(PKGROOT)/,$(MAN))
ALLSRC := $(ALLSRC) $(SRCMAN)
INSTMAN := $(addprefix doc/man/,$(MAN))
ALLINST := $(ALLINST) $(INSTMAN)
MAN = 

ifneq (,$(INSTMAN))
$(INSTMAN): doc/man/% : $(PKGROOT)/%
	$(MKINSTALL)
endif

# TXT supplied by package's Makefile.install.
TXT := $(strip $(TXT))
SRCTXT := $(addprefix $(PKGROOT)/,$(TXT))
ALLSRC := $(ALLSRC) $(SRCTXT)
INSTTXT := $(addprefix doc/txt/,$(TXT))
ALLINST := $(ALLINST) $(INSTTXT)
TXT = 

ifneq (,$(INSTTXT))
$(INSTTXT): doc/txt/% : $(PKGROOT)/%
	$(MKINSTALL)
endif

# HTML supplied by package's Makefile.install.
HTML := $(strip $(HTML))
SRCHTML := $(addprefix $(PKGROOT)/,$(HTML))
ALLSRC := $(ALLSRC) $(SRCHTML)
INSTHTML := $(addprefix doc/html/,$(HTML))
ALLINST := $(ALLINST) $(INSTHTML)
HTML = 

ifneq (,$(INSTHTML))
$(INSTHTML): doc/html/% : $(PKGROOT)/%
	$(MKINSTALL)
endif

# PS supplied by package's Makefile.install.
PS := $(strip $(PS))
SRCPS := $(addprefix $(PKGROOT)/,$(PS))
ALLSRC := $(ALLSRC) $(SRCPS)
INSTPS := $(addprefix doc/ps/,$(PS))
ALLINST := $(ALLINST) $(INSTPS)
PS = 

ifneq (,$(INSTPS))
$(INSTPS): doc/ps/% : $(PKGROOT)/%
	$(MKINSTALL)
endif

# FONTS supplied by package's Makefile.install.
FONTS := $(strip $(FONTS))
SRCFONTS := $(addprefix $(PKGROOT)/,$(FONTS))
ALLSRC := $(ALLSRC) $(SRCFONTS)
INSTFONTS := $(addprefix etc/fonts/,$(FONTS))
ALLINST := $(ALLINST) $(INSTFONTS)
FONTS = 

ifneq (,$(INSTFONTS))
$(INSTFONTS): etc/fonts/% : $(PKGROOT)/%
	$(MKINSTALL)
endif


# ICONS supplied by package's Makefile.install.
ICONS := $(strip $(ICONS))
SRCICONS := $(addprefix $(PKGROOT)/,$(ICONS))
ALLSRC := $(ALLSRC) $(SRCICONS)
INSTICONS := $(addprefix etc/icons/,$(ICONS))
ALLINST := $(ALLINST) $(INSTICONS)
ICONS = 

ifneq (,$(INSTICONS))
$(INSTICONS): etc/icons/% : $(PKGROOT)/%
	$(MKINSTALL)
endif


# APPDEFAULTS supplied by package's Makefile.install.
APPDEFAULTS := $(strip $(APPDEFAULTS))
SRCAPPDEFAULTS := $(addprefix $(PKGROOT)/,$(APPDEFAULTS))
ALLSRC := $(ALLSRC) $(SRCAPPDEFAULTS)
INSTAPPDEFAULTS := $(addprefix etc/app-defaults/,$(APPDEFAULTS))
ALLINST := $(ALLINST) $(INSTAPPDEFAULTS)
APPDEFAULTS = 

ifneq (,$(INSTAPPDEFAULTS))
$(INSTAPPDEFAULTS): etc/app-defaults/% : $(PKGROOT)/%
	$(MKINSTALL)
endif


# TCL supplied by package's Makefile.install.
TCL := $(strip $(TCL))
SRCTCL := $(addprefix $(PKGROOT)/,$(TCL))
ALLSRC := $(ALLSRC) $(SRCTCL)
INSTTCL := $(addprefix etc/tcl/,$(TCL))
ALLINST := $(ALLINST) $(INSTTCL)
TCL = 

ifneq (,$(INSTTCL))
$(INSTTCL): etc/tcl/% : $(PKGROOT)/%
	$(MKINSTALL)
endif


# TELEUSE supplied by package's Makefile.install.
TELEUSE := $(strip $(TELEUSE))
SRCTELEUSE := $(addprefix $(PKGROOT)/,$(TELEUSE))
ALLSRC := $(ALLSRC) $(SRCTELEUSE)
INSTTELEUSE := $(addprefix etc/teleuse/,$(TELEUSE))
ALLINST := $(ALLINST) $(INSTTELEUSE)
TELEUSE = 

ifneq (,$(INSTTELEUSE))
$(INSTTELEUSE): etc/teleuse/% : $(PKGROOT)/%
	$(MKINSTALL)
endif


# SHADERS supplied by package's Makefile.install.
SHADERS := $(strip $(SHADERS))
SRCSHADERS := $(addprefix $(PKGROOT)/,$(SHADERS))
ALLSRC := $(ALLSRC) $(SRCSHADERS)
INSTSHADERS := $(addprefix etc/shaders/,$(SHADERS))
ALLINST := $(ALLINST) $(INSTSHADERS)
SHADERS = 

ifneq (,$(INSTSHADERS))
$(INSTSHADERS): etc/shaders/% : $(PKGROOT)/%
	$(MKINSTALL)
endif


# OTHER supplied by package's Makefile.install.
OTHER := $(strip $(OTHER))
SRCOTHER := $(addprefix $(PKGROOT)/,$(notdir $(OTHER)))
ALLSRC := $(ALLSRC) $(SRCOTHER)
INSTOTHER := $(OTHER)
ALLINST := $(ALLINST) $(INSTOTHER)
OTHER = 
# Install actions for these files come from package's Makefile.install



#### Dependencies on files from other packages (same project).

ALLUSES = 

# USESLIBS supplied by package's Makefile.install.

ifeq (PS2, $(PENV))
  USESLIBS := $(USESLIBS:%.so=%.a)
endif

ifeq (WIN32,$(PENV))
  USESLIBS := $(USESLIBS:%.so=%$(DEBUGNAME).dll)
  USESLIBS := $(USESLIBS:%.a=%$(DEBUGNAME).lib)
endif # WIN32
ifeq (OSX,$(PENV))
  USESLIBS := $(USESLIBS:%.so=%.dylib)
endif # OSX
ALLUSES := $(ALLUSES) $(addprefix lib/,$(strip $(USESLIBS)))
USESLIBS = 

# USESINCLUDE supplied by package's Makefile.install.
ALLUSES := $(ALLUSES) $(addprefix inc/,$(strip $(USESINCLUDE)))
USESINCLUDE = 

# USESDEFERREDLIBS supplied by package's Makefile.install, but only
# respected if USE_DEFERRED is set.
ifneq (,$(USE_DEFERRED))
  ifeq (WIN32,$(PENV))
    USESDEFERREDLIBS := $(USESDEFERREDLIBS:%.so=%$(DEBUGNAME).dll)
    USESDEFERREDLIBS := $(USESDEFERREDLIBS:%.a=%$(DEBUGNAME).lib)
  endif # WIN32
  ifeq (OSX,$(PENV))
    USESDEFERREDLIBS := $(USESDEFERREDLIBS:%.so=%.dylib)
  endif # OS X
  ALLUSES := $(ALLUSES) $(addprefix lib/,$(strip $(USESDEFERREDLIBS)))
  USESDEFERREDLIBS = 
endif

# USESOTHER supplied by package's Makefile.install.
ALLUSES := $(ALLUSES) $(strip $(USESOTHER))
USESOTHER = 



#### Action targets
#
# The following series of targets all cause some action to take place in
# the project tree.  All of these actions may be done on a single
# package or on the entire project.  By default, any action done on a
# package is also done first on any packages it depends on.  This can be
# circumvented by setting NODEPEND to true.  
#
# One of the tricky things done in all the following rules was to not use 
# any variables in the build scripts.  This is necessary because this 
# rules files is read in multiple times in a project build, and the 
# variable are set multiple times.  However, build scripts are executed
# at the end of the read process, after dependency resolution.  At that
# time, variables have the value they were last set to.  Instead, the
# approach is to place the variables in the dependency lists and target
# names, since these are resolved as the file is read.
#

#### Installation and build rules.

# To install project, install all packages.
install-$(CTPROJECT): install-$(PKGROOT)

# To install package, must build all installed files.
install-$(PKGROOT):  announce-install-$(PKGROOT) $(ALLINST)

# Synonym for installing a package.
install-$(PACKAGE): install-$(PKGROOT)

# $(ALLINST) : $(ALLSRC) done in install actions section above.

## Before installing, announce that installation is starting.
#ifneq (,$(ALLSRC))
#$(ALLSRC): announce-install-$(PKGROOT)
#endif

# State that we're installing files from the package.  Build first.
announce-install-$(PKGROOT): build-$(PKGROOT)
	@echo '***' Installing from $(strip-target) '...'

# Check for Makefile in package.  If found, make it.
ifeq (,$(NODEPEND))
build-$(PKGROOT) : $(addprefix install-,$(ALLUSES))
else
build-$(PKGROOT) :
endif
	@cd $(CTPROJROOT)/$(strip-target); if [ -r Makefile ]; then echo '***' Building $(strip-target) '...'; \
	$(MAKE) install; fi

# Convenient synonym for build.
build-$(PACKAGE): build-$(PKGROOT)

# Provide hooks for other packages to transmit build dependencies.
ifneq (,$(ALLINST))
$(addprefix install-,$(ALLINST)): install-$(PKGROOT)
endif



#### Clean rules.

# To clean project, clean each package.
clean-$(CTPROJECT): clean-$(PKGROOT)

# Synonym to clean a particular package.
clean-$(PACKAGE): clean-$(PKGROOT)

ifneq (,$(ALLINST))
$(addprefix clean-,$(ALLINST)): clean-$(PKGROOT)
endif

# To clean package, cd to it and do 'make clean' (if there's a Makefile).
ifeq (,$(NODEPEND))
clean-$(PKGROOT) : $(addprefix clean-,$(ALLUSES))
else
clean-$(PKGROOT) :
endif
	@cd $(CTPROJROOT)/$(strip-target); if [ -r Makefile ]; then echo '***' Cleaning $(strip-target) '...'; \
	$(MAKE) clean; fi



#### Cleanall rules.

# To clean project, clean each package.
cleanall-$(CTPROJECT): cleanall-$(PKGROOT)

# Synonym to cleanall a particular package.
cleanall-$(PACKAGE): cleanall-$(PKGROOT)

ifneq (,$(ALLINST))
$(addprefix cleanall-,$(ALLINST)): cleanall-$(PKGROOT)
endif

# To cleanall package, cd to it and do 'make cleanall' (if there's a Makefile).
ifeq (,$(NODEPEND))
cleanall-$(PKGROOT) : $(addprefix cleanall-,$(ALLUSES))
else
cleanall-$(PKGROOT) :
endif
	@cd $(CTPROJROOT)/$(strip-target); if [ -r Makefile ]; then echo '***' Wiping $(strip-target) '...'; \
	$(MAKE) cleanall; fi



#### Uninstall rules.

# To uninstall project, must uninstall each package.
uninstall-$(CTPROJECT): uninstall-$(PKGROOT)

# To uninstall package, must remove each installed file.
uninstall-$(PKGROOT): $(addprefix uninstall-,$(ALLINST))

# Synonym for uninstalling a package.
uninstall-$(PACKAGE): uninstall-$(PKGROOT)

# To remove file, check if it's there and rm it.
ifneq (,$(ALLINST))
$(addprefix uninstall-,$(ALLINST)): announce-uninstall-$(PKGROOT)
	@if [ -r $(strip-target) ]; then echo $(strip-target); rm -rf $(strip-target); fi

$(addprefix touninstall-,$(ALLINST)): uninstall-$(PKGROOT)
endif

# Announce uninstallation.  First uninstall dependent packages.
ifeq (,$(NODEPEND))
announce-uninstall-$(PKGROOT): $(addprefix touninstall-,$(ALLUSES))
else
announce-uninstall-$(PKGROOT):
endif
	@echo '***' Uninstalling from package $(strip-target) '...'



#### Touch rules.

# To touch project, must touch each package.
touch-$(CTPROJECT): touch-$(PKGROOT)

# To touch package, must touch each installed file.
touch-$(PKGROOT): $(addprefix touch-,$(ALLINST))

# Synonym for touching a package.
touch-$(PACKAGE): touch-$(PKGROOT)

# To touch file, check if it's there and touch it.  Works on directories.
ifneq (,$(ALLINST))
$(addprefix touch-,$(ALLINST)): announce-touch-$(PKGROOT)
	@if [ -r $(strip-target) ]; then find $(strip-target) -print -exec touch {} \; ; fi

$(addprefix totouch-,$(ALLINST)): touch-$(PKGROOT)
endif

# Announce touch.  First touch dependent packages.
ifeq (,$(NODEPEND))
announce-touch-$(PKGROOT): $(addprefix totouch-,$(ALLUSES))
else
announce-touch-$(PKGROOT):
endif
	@echo '***' Touching package $(strip-target) '...'



#### Copy rules.

# To copy project, must copy each package.
copy-$(CTPROJECT): copy-$(PKGROOT)

# To copy package, must copy each installed file.
copy-$(PKGROOT): $(addprefix copy-,$(ALLINST))

# Synonym for copying a package.
copy-$(PACKAGE): copy-$(PKGROOT)

ifneq (,$(ALLINST))
$(addprefix copy-,$(ALLINST)): announce-copy-$(PKGROOT)
ifneq (,$(CTFROM))
	@if [ ! -d $(*D) ]; then mkdir $(*D); fi
	@cp -r $(CTFROM)/$(strip-target) $(strip-target) && echo $(strip-target)
else
	@echo CTFROM variable not set; exit 1
endif

$(addprefix tocopy-,$(ALLINST)): copy-$(PKGROOT)
endif

# Announce copy.  First copy dependent packages.
ifeq (,$(NODEPEND))
announce-copy-$(PKGROOT): $(addprefix tocopy-,$(ALLUSES))
else
announce-copy-$(PKGROOT):
endif
	@echo '***' Copying package $(strip-target) '...'



#### Query targets.
#
# The following rules use the project makefile as a database, to which
# various questions can be put, such as 'what files does this package
# install?', 'which files are currently installed?', and 'what packages
# must be built before this package can be built?'.  These targets take
# no action in the project, they just produce a list of one or more 
# answers.  As in the action targets, interpackage dependencies are used
# to automatically propagate the question from a package to its
# dependency packages (those it needs to build).

#### Query files to be installed by a package.

# To find files installed by project, query each package.
toinstall-$(CTPROJECT): toinstall-$(PKGROOT)

# Convenient synonym for toinstall.
toinstall-$(PACKAGE): toinstall-$(PKGROOT)

# To list package, list each file installed by package.
toinstall-$(PKGROOT): $(addprefix toinstall-,$(ALLINST))

# Echo each installed file's name.  First announce the package.
ifneq (,$(ALLINST))
$(addprefix toinstall-,$(ALLINST)): announce-toinstall-$(PKGROOT)
	@echo $(strip-target)

$(addprefix totoinstall-,$(ALLINST)): toinstall-$(PKGROOT)
endif

ifeq (,$(NODEPEND))
announce-toinstall-$(PKGROOT): $(addprefix totoinstall-,$(ALLUSES))
else
announce-toinstall-$(PKGROOT):
endif
	@echo '***' To be installed from $(strip-target) '...'




#### Query files that have been installed by a package.

isinstalled-$(CTPROJECT): isinstalled-$(PKGROOT)

isinstalled-$(PKGROOT): $(addprefix isinstalled-,$(ALLINST))

isinstalled-$(PACKAGE): isinstalled-$(PKGROOT)

ifneq (,$(ALLINST))
$(addprefix isinstalled-,$(ALLINST)): announce-isinstalled-$(PKGROOT)
	@if [ -r $(strip-target) ]; then echo $(strip-target); fi

$(addprefix toisinstalled-,$(ALLINST)): isinstalled-$(PKGROOT)
endif

ifeq (,$(NODEPEND))
announce-isinstalled-$(PKGROOT): $(addprefix toisinstalled-,$(ALLUSES))
else
announce-isinstalled-$(PKGROOT):
endif
	@echo '***' Currently installed from $(strip-target) '...'



#### Query files that have not been installed by a package.

notinstalled-$(CTPROJECT): notinstalled-$(PKGROOT)

notinstalled-$(PKGROOT): $(addprefix notinstalled-,$(ALLINST))

notinstalled-$(PACKAGE): notinstalled-$(PKGROOT)

ifneq (,$(ALLINST))
$(addprefix notinstalled-,$(ALLINST)): announce-notinstalled-$(PKGROOT)
	@if [ ! -r $(strip-target) ]; then echo $(strip-target); fi

$(addprefix tonotinstalled-,$(ALLINST)): notinstalled-$(PKGROOT)
endif

ifeq (,$(NODEPEND))
announce-notinstalled-$(PKGROOT): $(addprefix tonotinstalled-,$(ALLUSES))
else
announce-notinstalled-$(PKGROOT):
endif
	@echo '***' Not currently installed from $(strip-target) '...'



#### Check that a package is completely installed.

checkinstall-$(CTPROJECT): checkinstall-$(PKGROOT)

checkinstall-$(PACKAGE): checkinstall-$(PKGROOT)

checkinstall-$(PKGROOT): $(addprefix checkinstall-,$(ALLINST))

ifneq (,$(ALLINST))
$(addprefix checkinstall-,$(ALLINST)): announce-checkinstall-$(PKGROOT)
	@if [ ! -r $(strip-target) ]; then exit 1; fi

$(addprefix tocheckinstall-,$(ALLINST)): checkinstall-$(PKGROOT)
endif

ifeq (,$(NODEPEND))
announce-checkinstall-$(PKGROOT): $(addprefix tocheckinstall-,$(ALLUSES))
else
announce-checkinstall-$(PKGROOT):
endif
	@echo '***' Checking installation from $(strip-target) '...'



#### Query files used to build a package.

# To find files needed in project, query each package.
showuses-$(CTPROJECT): showuses-$(PKGROOT)

# Convenient synonym for showuses.
showuses-$(PACKAGE): showuses-$(PKGROOT)

showuses-$(PKGROOT): $(addprefix showuses-,$(ALLUSES))
	@echo '***' Files declared as needed to build $(strip-target) '...'
	@if expr "$^" != "" > /dev/null; then echo $^ | sed -e 's/showuses-//g' | tr " " "\012"; fi

ifneq (,$(NODEPEND))

ifneq (,$(ALLUSES))
$(addprefix showuses-,$(ALLUSES)): 

endif

else

ifneq (,$(ALLINST))
$(addprefix showuses-,$(ALLINST)): showuses-$(PKGROOT)

endif

endif



#### Find package location given installed file, or package name.

ifneq (,$(ALLINST))
$(addprefix find-,$(ALLINST)): find-$(PKGROOT)
endif

find-$(PKGROOT):
	@echo $(strip-target)

find-$(PACKAGE): find-$(PKGROOT)



#### List packages that need this package in order to build successfully.

# A package needs this package if it needs any of its files.
needs-$(PACKAGE): $(addprefix needs-,$(ALLINST))

# Define empty targets for needs-installed-files.  Ensures successful 
# completion.
ifneq (,$(ALLINST))
$(addprefix needs-,$(ALLINST)):
endif

# Needing the file mean the package has a prerequisite.
ifneq (,$(ALLUSES))
$(addprefix needs-,$(ALLUSES)): prereq-$(PKGROOT)
endif

# Print all packages with prerequisites triggered by original package.
# Possibly propagate prerequisites on to other packages.
ifeq (,$(NODEPEND))
prereq-$(PKGROOT): $(addprefix needs-,$(ALLINST))
else
prereq-$(PKGROOT):
endif
	@echo $(strip-target)



#### List packages used to build this package (opposite of above).

depends-$(CTPROJECT): depends-$(PKGROOT)

depends-$(PKGROOT):

ifneq (,$(ALLINST))
$(addprefix depends-,$(ALLINST)): requires-$(PKGROOT)
endif

ifneq (,$(ALLUSES))

depends-$(PKGROOT): $(addprefix depends-,$(ALLUSES))

ifeq (,$(NODEPEND))
requires-$(PKGROOT): $(addprefix depends-,$(ALLUSES))
else
requires-$(PKGROOT):
endif
	@echo $(strip-target)

endif

depends-$(PACKAGE): depends-$(PKGROOT)



#### List packages that do not depend on other packages.

nodepends-$(CTPROJECT): nodepends-$(PKGROOT)

ifeq (,$(strip $(ALLUSES)))
nodepends-$(PKGROOT):
	@echo $(strip-target)	

else
nodepends-$(PKGROOT):

endif



#### List files included by a package.

# To clean project, clean each package.
includes-$(CTPROJECT): includes-$(PKGROOT)

# Synonym to includes a particular package.
includes-$(PACKAGE): includes-$(PKGROOT)

ifneq (,$(ALLINST))
$(addprefix includes-,$(ALLINST)): includes-$(PKGROOT)
endif

# Call ctshowdep on package
ifeq (,$(NODEPEND))
includes-$(PKGROOT) : $(addprefix includes-,$(ALLUSES))
else
includes-$(PKGROOT) :
endif
	@echo '***' Files included by $(strip-target) '...'
	-ctshowdep $(CTINC) $(strip-target)
